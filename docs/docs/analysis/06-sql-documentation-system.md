# SQL Documentation System Analysis

## Overview

The codebase includes a comprehensive SQL documentation system that serves as reference documentation for understanding what SQL queries the ORM generates. These files are **documentation only** - they are not executed by the application.

## 1. Purpose and Philosophy

### Documentation-Only Approach

**Key Principle:**

- SQL files are reference documentation
- Actual queries generated by SQLAlchemy ORM
- Illustrates query patterns and optimization strategies
- Helps developers understand ORM behavior

**Benefits:**

- Clear documentation of query logic
- Performance optimization reference
- Debugging aid
- Learning resource

## 2. Directory Structure

### Organization by API Version

```txt
sql/apis/
├── README.md                    # System overview
├── ENDPOINT_MAPPING.md          # Complete endpoint mapping
├── system/                      # System endpoints
│   ├── health_check.sql
│   ├── application_health.sql
│   └── root_metadata.sql
├── v1/                          # API v1 endpoints
│   ├── contacts/
│   │   ├── core/               # Core operations
│   │   └── attributes/         # Attribute lists
│   ├── companies/
│   │   ├── core/
│   │   ├── attributes/
│   │   └── contacts/           # Company contact operations
│   └── imports/
└── v2/                          # API v2 endpoints
    ├── auth/
    ├── users/
    ├── ai_chats/
    ├── apollo/
    └── exports/
```

### Naming Conventions

**File Naming:**

- Lowercase with underscores
- Operation prefix: `list_`, `count_`, `retrieve_`, `create_`, `update_`, `delete_`
- Resource name: `contacts`, `companies`, etc.
- Example: `list_contacts.sql`, `get_contact_uuids.sql`

**Directory Organization:**

- Group by API version (v1, v2)
- Group by resource (contacts, companies, etc.)
- Separate core operations from attributes
- Company-specific operations: `companies/contacts/`

## 3. File Format Standard

### Header Section

**Required Elements:**

- Endpoint path
- API version
- Description
- Request/response details

**Example:**

```sql
-- ============================================================================
-- Endpoint: POST /api/v2/apollo/contacts/count/uuids
-- API Version: v2
-- Description: Get contact UUIDs matching Apollo.io URL parameters
-- ============================================================================
```

### Parameters Section

**Documents:**

- Query parameters
- Path parameters
- Body parameters
- Types and descriptions
- Optional vs required

**Example:**

```sql
-- Request Body Parameters:
--   $1: url (text, required) - Apollo.io URL to analyze

-- Query Parameters (All optional):
--   include_company_name (text) - Include contacts whose company name matches
--   limit (integer, optional) - Maximum number of UUIDs to return
```

### Response Structure

**Documents:**

- Response schema
- Field descriptions
- Example responses

**Example:**

```sql
-- Response Structure:
-- {
--   "count": 1234,
--   "uuids": ["uuid1", "uuid2", "uuid3", ...]
-- }
```

### Response Codes

**Documents:**

- HTTP status codes
- Error conditions
- Success conditions

**Example:**

```sql
-- Response Codes:
--   200 OK: UUIDs retrieved successfully
--   400 Bad Request: Invalid URL or filter parameters
--   401 Unauthorized: Authentication required
```

### ORM Implementation Notes

**Critical Section:**

- Documents conditional JOIN logic
- Explains when JOINs are added
- Notes query optimization strategies
- References actual ORM methods

**Example:**

```sql
-- ORM Implementation Notes:
--   Uses ContactRepository.get_uuids_by_filters():
--   - Uses SAME conditional JOIN logic as get_contact_uuids
--   - Apollo URL parameters parsed in application layer
--   - Returns list[str] of UUIDs (not array_agg in SQL)
```

### Query Examples

**Multiple Scenarios:**

- Minimal query (no filters)
- With filters
- With pagination
- With special conditions

**Example:**

```sql
-- Query 1: Get all matching contact UUIDs (no limit)
SELECT c.uuid
FROM contacts c
WHERE 1=1
    -- Apply converted Apollo filter conditions here

-- Query 2: Get contact UUIDs with limit
WITH filtered_contacts AS (
    SELECT c.uuid
    FROM contacts c
    LEFT JOIN companies co ON c.company_id = co.uuid
    WHERE 1=1
        -- Apply filter conditions
    LIMIT 100
)
SELECT 
    (SELECT COUNT(*) FROM ...) as count,
    array_agg(uuid ORDER BY uuid) as uuids
FROM filtered_contacts;
```

## 4. Conditional JOIN Documentation

### JOIN Detection Logic

**Documented Patterns:**

- When Company join is needed
- When ContactMetadata join is needed
- When CompanyMetadata join is needed
- Default ordering (no join required)

**Example:**

```sql
-- Conditional JOINs:
--   No filters → Only contacts table (no joins)
--   Company filter → LEFT JOIN companies
--   Metadata filter → LEFT JOIN contacts_metadata and/or companies_metadata
```

### Optimization Notes

**Performance Considerations:**

- Minimal queries are fastest
- JOINs only when necessary
- Default ordering uses indexed fields
- EXISTS subqueries as fallback

## 5. Parameter Mapping Documentation

### Apollo Parameter Mapping

**Documents:**

- Apollo URL parameter → ContactFilter mapping
- Parameter conversion logic
- Unmapped parameters
- Special handling (titles, locations, etc.)

**Example:**

```sql
-- Parameter Mappings:
--   Apollo personTitles[]=CEO → title filter
--   Apollo personLocations[]=California → contact_location filter
--   Apollo organizationNumEmployeesRanges[]=11,50 → employees_min=11, employees_max=50
```

## 6. Query Pattern Documentation

### Common Patterns

**1. List Operations:**

```sql
SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ... OFFSET ...
```

**2. Count Operations:**

```sql
SELECT COUNT(...) FROM ... WHERE ...
```

**3. Retrieve Operations:**

```sql
SELECT ... FROM ... WHERE uuid = $1
```

**4. Create Operations:**

```sql
INSERT INTO ... VALUES (...) RETURNING ...
```

**5. Update Operations:**

```sql
UPDATE ... SET ... WHERE uuid = $1 RETURNING ...
```

**6. Delete Operations:**

```sql
DELETE FROM ... WHERE uuid = $1
```

## 7. Filter Application Order

### Documented Order

**1. Contact/Company Field Filters:**

- Direct column filters
- Simple ILIKE matching

**2. Company Filters (if join exists):**

- Company name, location
- Employee/revenue/funding ranges
- Array filters (technologies, keywords, industries)

**3. Metadata Filters (if joins exist):**

- ContactMetadata fields
- CompanyMetadata fields

**4. Special Filters:**

- Domain filtering
- Keyword field control
- Search terms

## 8. ENDPOINT_MAPPING.md

### Purpose

**Complete Mapping:**

- Maps every endpoint to its SQL documentation file
- Organized by API version
- Includes HTTP method and path

**Example:**

```txt
GET /api/v1/contacts/ → v1/contacts/core/list_contacts.sql
GET /api/v1/contacts/count/ → v1/contacts/core/count_contacts.sql
POST /api/v2/apollo/contacts → v2/apollo/search_contacts.sql
```

## 9. Usage Guidelines

### For Developers

**Understanding Query Logic:**

- See what SQL the ORM generates
- Understand JOIN conditions
- Learn filter application patterns

**Performance Optimization:**

- Identify when JOINs are added
- Understand query complexity
- Plan index strategies

**Debugging:**

- Compare actual ORM queries with documented examples
- Verify JOIN logic
- Check filter application

### For Database Administrators

**Query Analysis:**

- Reference for EXPLAIN ANALYZE
- Understand query patterns
- Plan index optimization

**Performance Tuning:**

- Identify optimization opportunities
- Understand query complexity
- Plan connection pool sizing

## 10. Maintenance

### Keeping Documentation Current

**When to Update:**

- New endpoints added
- Filter logic changes
- JOIN optimization changes
- Parameter mappings updated

**Update Process:**

1. Match ORM logic in repository
2. Update SQL examples
3. Document JOIN conditions
4. Update ENDPOINT_MAPPING.md
5. Include examples for different scenarios

## 11. Key Features

### Comprehensive Coverage

**All Endpoints Documented:**

- v1 and v2 endpoints
- Core operations
- Attribute lists
- Special operations (Apollo, imports, exports)

### Multiple Query Scenarios

**Each File Includes:**

- Minimal query (no filters)
- With filters
- With pagination
- With special conditions

### Clear Annotations

**Comments Explain:**

- Parameter placeholders ($1, $2)
- Filter application logic
- JOIN conditions
- Optimization strategies

## 12. Relationship to ORM Code

### Mapping to Repositories

**ContactRepository:**

- `list_contacts()` → `list_contacts.sql`
- `count_contacts()` → `count_contacts.sql`
- `get_uuids_by_filters()` → `get_contact_uuids.sql`

**CompanyRepository:**

- `list_companies()` → `list_companies.sql`
- Similar mapping pattern

### Parameter Placeholders

**Documentation Uses:**

- `$1`, `$2`, etc. for parameter placeholders
- Actual ORM uses bound parameters
- Examples show parameter positions

## Summary

The SQL documentation system provides:

1. **Comprehensive Reference**: All endpoints documented
2. **Clear Structure**: Organized by version and resource
3. **Multiple Scenarios**: Different query patterns documented
4. **Optimization Notes**: JOIN logic and performance considerations
5. **Maintenance Guide**: How to keep documentation current
6. **Developer Aid**: Helps understand ORM behavior

This system bridges the gap between ORM code and actual SQL queries, making the codebase more understandable and maintainable.
