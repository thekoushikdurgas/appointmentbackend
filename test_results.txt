.s....................................................FFFF......FF...... [ 23%]
.......................F....x..............F.FFFFFFFFFFFFFFFFFFFFFFFFFFF [ 46%]
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF..s [ 69%]
ssssssss.s.....F.....................................FFF...FFFFF.FFFFFFF [ 92%]
FFFFF.F.................API report: D:\code\ayan\appoinmentbackend\@results\20251110_163712\api_test_report.txt
API results JSON: D:\code\ayan\appoinmentbackend\@results\20251110_163712\api_test_results.json
API responses directory: D:\code\ayan\appoinmentbackend\@results\20251110_163712\responses
                                                                         [100%]
================================== FAILURES ===================================
_ TestContactsList.test_individual_filters[created_at_after-2024-01-01T00:00:00Z] _

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A12A5D0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_individual_filters[created_at_after-2024-01-01T00:00:00Z]>>)
filter_name = 'created_at_after', test_value = '2024-01-01T00:00:00Z'

    @pytest.mark.parametrize(
        "filter_name,test_value",
        [
            (filter_name, _first_non_empty(values))
            for filter_name, values in CONTACT_FILTERS.items()
            if _first_non_empty(values) is not None and _first_non_empty(values) != ""
        ],
    )
    def test_individual_filters(self, api_request, filter_name: str, test_value: Any):
        allow_timeout = filter_name in SLOW_FILTERS
>       api_request(
            "GET",
            api_v1_path("/contacts/"),
            params={filter_name: test_value},
            expected_status=200,
            allow_timeout=allow_timeout,
        )

app\tests\integration\test_api_endpoints.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 500, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_ TestContactsList.test_individual_filters[created_at_before-2025-01-01T00:00:00Z] _

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A12A690>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_individual_filters[created_at_before-2025-01-01T00:00:00Z]>>)
filter_name = 'created_at_before', test_value = '2025-01-01T00:00:00Z'

    @pytest.mark.parametrize(
        "filter_name,test_value",
        [
            (filter_name, _first_non_empty(values))
            for filter_name, values in CONTACT_FILTERS.items()
            if _first_non_empty(values) is not None and _first_non_empty(values) != ""
        ],
    )
    def test_individual_filters(self, api_request, filter_name: str, test_value: Any):
        allow_timeout = filter_name in SLOW_FILTERS
>       api_request(
            "GET",
            api_v1_path("/contacts/"),
            params={filter_name: test_value},
            expected_status=200,
            allow_timeout=allow_timeout,
        )

app\tests\integration\test_api_endpoints.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 500, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_ TestContactsList.test_individual_filters[updated_at_after-2024-01-01T00:00:00Z] _

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A12A750>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_individual_filters[updated_at_after-2024-01-01T00:00:00Z]>>)
filter_name = 'updated_at_after', test_value = '2024-01-01T00:00:00Z'

    @pytest.mark.parametrize(
        "filter_name,test_value",
        [
            (filter_name, _first_non_empty(values))
            for filter_name, values in CONTACT_FILTERS.items()
            if _first_non_empty(values) is not None and _first_non_empty(values) != ""
        ],
    )
    def test_individual_filters(self, api_request, filter_name: str, test_value: Any):
        allow_timeout = filter_name in SLOW_FILTERS
>       api_request(
            "GET",
            api_v1_path("/contacts/"),
            params={filter_name: test_value},
            expected_status=200,
            allow_timeout=allow_timeout,
        )

app\tests\integration\test_api_endpoints.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 500, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_ TestContactsList.test_individual_filters[updated_at_before-2025-01-01T00:00:00Z] _

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A12A810>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_individual_filters[updated_at_before-2025-01-01T00:00:00Z]>>)
filter_name = 'updated_at_before', test_value = '2025-01-01T00:00:00Z'

    @pytest.mark.parametrize(
        "filter_name,test_value",
        [
            (filter_name, _first_non_empty(values))
            for filter_name, values in CONTACT_FILTERS.items()
            if _first_non_empty(values) is not None and _first_non_empty(values) != ""
        ],
    )
    def test_individual_filters(self, api_request, filter_name: str, test_value: Any):
        allow_timeout = filter_name in SLOW_FILTERS
>       api_request(
            "GET",
            api_v1_path("/contacts/"),
            params={filter_name: test_value},
            expected_status=200,
            allow_timeout=allow_timeout,
        )

app\tests\integration\test_api_endpoints.py:525: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 500, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestContactsList.test_filter_combinations[params6] ______________

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A12B590>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_filter_combinations[params6]>>)
params = {'created_at_after': '2024-01-01T00:00:00Z', 'updated_at_before': '2025-01-01T00:00:00Z'}

    @pytest.mark.parametrize("params", FILTER_COMBINATIONS)
    def test_filter_combinations(self, api_request, params: Mapping[str, Any]):
>       api_request("GET", api_v1_path("/contacts/"), params=params, expected_status=200)

app\tests\integration\test_api_endpoints.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 500, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestContactsList.test_filter_combinations[params7] ______________

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001A23A280950>
method = 'GET'
url = '/api/v1/contacts/?title=cto&seniority=director&country=US', body = None
headers = {'User-Agent': 'python-requests/2.32.5', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'X-Request-Id': 'pytest-1762772346742'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=120.0, read=120.0, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/contacts/', query='title=cto&seniority=director&country=US', fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connectionpool.py:534: in _make_request
    response = conn.getresponse()
               ^^^^^^^^^^^^^^^^^^
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connection.py:565: in getresponse
    httplib_response = super().getresponse()
                       ^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\http\client.py:1430: in getresponse
    response.begin()
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\http\client.py:331: in begin
    version, status, reason = self._read_status()
                              ^^^^^^^^^^^^^^^^^^^
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\http\client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <socket.SocketIO object at 0x000001A23A292590>
b = <memory at 0x000001A23A9EAC80>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)
                       ^^^^^^^^^^^^^^^^^^^^^^^
E               ConnectionResetError: [WinError 10054] An existing connection was forcibly closed by the remote host

C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\socket.py:720: ConnectionResetError

During handling of the above exception, another exception occurred:

self = <requests.adapters.HTTPAdapter object at 0x000001A23A1DD760>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=120.0, read=120.0, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\requests\adapters.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\util\retry.py:474: in increment
    raise reraise(type(error), error, _stacktrace)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\util\util.py:38: in reraise
    raise value.with_traceback(tb)
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connectionpool.py:787: in urlopen
    response = self._make_request(
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connectionpool.py:534: in _make_request
    response = conn.getresponse()
               ^^^^^^^^^^^^^^^^^^
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\urllib3\connection.py:565: in getresponse
    httplib_response = super().getresponse()
                       ^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\http\client.py:1430: in getresponse
    response.begin()
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\http\client.py:331: in begin
    version, status, reason = self._read_status()
                              ^^^^^^^^^^^^^^^^^^^
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\http\client.py:292: in _read_status
    line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <socket.SocketIO object at 0x000001A23A292590>
b = <memory at 0x000001A23A9EAC80>

    def readinto(self, b):
        """Read up to len(b) bytes into the writable buffer *b* and return
        the number of bytes read.  If the socket is non-blocking and no bytes
        are available, None is returned.
    
        If *b* is non-empty, a 0 return value indicates that the connection
        was shutdown at the other end.
        """
        self._checkClosed()
        self._checkReadable()
        if self._timeout_occurred:
            raise OSError("cannot read from timed out object")
        while True:
            try:
>               return self._sock.recv_into(b)
                       ^^^^^^^^^^^^^^^^^^^^^^^
E               urllib3.exceptions.ProtocolError: ('Connection aborted.', ConnectionResetError(10054, 'An existing connection was forcibly closed by the remote host', None, 10054, None))

C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.12_3.12.2800.0_x64__qbz5n2kfra8p0\Lib\socket.py:720: ProtocolError

During handling of the above exception, another exception occurred:

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
>           response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )

app\tests\integration\test_api_endpoints.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001A23A1DD760>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=120.0, read=120.0, total=None), verify = True
cert = None, proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection_with_tls_context(
                request, verify, proxies=proxies, cert=cert
            )
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
>           raise ConnectionError(err, request=request)
E           requests.exceptions.ConnectionError: ('Connection aborted.', ConnectionResetError(10054, 'An existing connection was forcibly closed by the remote host', None, 10054, None))

C:\Users\durga\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0\LocalCache\local-packages\Python312\site-packages\requests\adapters.py:659: ConnectionError

During handling of the above exception, another exception occurred:

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A12B650>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_filter_combinations[params7]>>)
params = {'country': 'US', 'seniority': 'director', 'title': 'cto'}

    @pytest.mark.parametrize("params", FILTER_COMBINATIONS)
    def test_filter_combinations(self, api_request, params: Mapping[str, Any]):
>       api_request("GET", api_v1_path("/contacts/"), params=params, expected_status=200)

app\tests\integration\test_api_endpoints.py:535: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
>           pytest.fail(f"{method} {url} request error: {exc}")
E           Failed: GET http://localhost:8000/api/v1/contacts/ request error: ('Connection aborted.', ConnectionResetError(10054, 'An existing connection was forcibly closed by the remote host', None, 10054, None))

app\tests\integration\test_api_endpoints.py:359: Failed
___________________ TestContactsList.test_multiple_ordering ___________________

self = <app.tests.integration.test_api_endpoints.TestContactsList object at 0x000001A23A1561E0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_multiple_ordering>>)

    def test_multiple_ordering(self, api_request):
>       api_request(
            "GET",
            api_v1_path("/contacts/"),
            params={"ordering": "country,-employees,created_at"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:567: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 400, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestContactsCount.test_count_with_date_range _________________

self = <app.tests.integration.test_api_endpoints.TestContactsCount object at 0x000001A23A179C70>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_count_with_date_range>>)

    def test_count_with_date_range(self, api_request):
>       api_request(
            "GET",
            api_v1_path("/contacts/count/"),
            params={"created_at_after": "2024-01-01T00:00:00Z"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:698: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/count/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/count/ returned 500, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________________ TestFieldEndpoints.test_field_basic[title] __________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A178980>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[title]>>)
field_name = 'title'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_basic[company] _________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A330>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[company]>>)
field_name = 'company'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_basic[industry] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A3F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[industry]>>)
field_name = 'industry'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_basic[keywords] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A4B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[keywords]>>)
field_name = 'keywords'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_basic[technologies] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A570>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[technologies]>>)
field_name = 'technologies'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________________ TestFieldEndpoints.test_field_basic[city] __________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A630>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[city]>>)
field_name = 'city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________________ TestFieldEndpoints.test_field_basic[state] __________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A6F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[state]>>)
field_name = 'state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_basic[country] _________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A7B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[country]>>)
field_name = 'country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_basic[company_address] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A870>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[company_address]>>)
field_name = 'company_address'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_basic[company_city] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A930>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[company_city]>>)
field_name = 'company_city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_basic[company_state] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17A9F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[company_state]>>)
field_name = 'company_state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_basic[company_country] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17AAB0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_basic[company_country]>>)
field_name = 'company_country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_basic(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:718: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[fintech-title] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17B020>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-title]>>)
field_name = 'title', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_search[fintech-company] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17AFC0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-company]>>)
field_name = 'company', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_search[fintech-industry] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17B680>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-industry]>>)
field_name = 'industry', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_search[fintech-keywords] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17B740>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-keywords]>>)
field_name = 'keywords', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________ TestFieldEndpoints.test_field_search[fintech-technologies] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17B800>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-technologies]>>)
field_name = 'technologies', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[fintech-city] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17B8C0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-city]>>)
field_name = 'city', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[fintech-state] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17B980>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-state]>>)
field_name = 'state', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_search[fintech-country] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BA40>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-country]>>)
field_name = 'country', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________ TestFieldEndpoints.test_field_search[fintech-company_address] ________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BB00>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-company_address]>>)
field_name = 'company_address', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________ TestFieldEndpoints.test_field_search[fintech-company_city] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BBC0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-company_city]>>)
field_name = 'company_city', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________ TestFieldEndpoints.test_field_search[fintech-company_state] _________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BC80>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-company_state]>>)
field_name = 'company_state', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________ TestFieldEndpoints.test_field_search[fintech-company_country] ________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BD40>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[fintech-company_country]>>)
field_name = 'company_country', term = 'fintech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_search[tech-title] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BE30>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-title]>>)
field_name = 'title', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[tech-company] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BF20>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-company]>>)
field_name = 'company', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[tech-industry] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17BFE0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-industry]>>)
field_name = 'industry', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[tech-keywords] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C0E0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-keywords]>>)
field_name = 'keywords', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_search[tech-technologies] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C1A0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-technologies]>>)
field_name = 'technologies', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_search[tech-city] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C260>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-city]>>)
field_name = 'city', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_search[tech-state] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C320>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-state]>>)
field_name = 'state', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_search[tech-country] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A157200>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-country]>>)
field_name = 'country', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________ TestFieldEndpoints.test_field_search[tech-company_address] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C410>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-company_address]>>)
field_name = 'company_address', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_search[tech-company_city] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C4D0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-company_city]>>)
field_name = 'company_city', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_search[tech-company_state] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C590>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-company_state]>>)
field_name = 'company_state', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_________ TestFieldEndpoints.test_field_search[tech-company_country] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19C650>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_search[tech-company_country]>>)
field_name = 'company_country', term = 'tech'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    @pytest.mark.parametrize("term", SEARCH_TERMS[:2])
    def test_field_search(self, api_request, field_name: str, term: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": term},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:727: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_distinct[title] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19CA70>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[title]>>)
field_name = 'title'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_distinct[company] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19CE60>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[company]>>)
field_name = 'company'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_distinct[industry] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19CF20>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[industry]>>)
field_name = 'industry'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_distinct[keywords] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19CFE0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[keywords]>>)
field_name = 'keywords'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_distinct[technologies] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D0A0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[technologies]>>)
field_name = 'technologies'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_distinct[city] _________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D160>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[city]>>)
field_name = 'city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_distinct[state] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D220>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[state]>>)
field_name = 'state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_distinct[country] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D2E0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[country]>>)
field_name = 'country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_distinct[company_address] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D3A0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[company_address]>>)
field_name = 'company_address'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_distinct[company_city] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D460>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[company_city]>>)
field_name = 'company_city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_distinct[company_state] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D520>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[company_state]>>)
field_name = 'company_state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_distinct[company_country] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19D5E0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_distinct[company_country]>>)
field_name = 'company_country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_distinct(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"distinct": "true"},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:736: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_pagination[title] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19DA00>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[title]>>)
field_name = 'title'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_pagination[company] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19DDF0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[company]>>)
field_name = 'company'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_pagination[industry] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19DEB0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[industry]>>)
field_name = 'industry'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_pagination[keywords] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19DF70>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[keywords]>>)
field_name = 'keywords'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_pagination[technologies] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E030>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[technologies]>>)
field_name = 'technologies'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_pagination[city] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E0F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[city]>>)
field_name = 'city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_pagination[state] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E1B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[state]>>)
field_name = 'state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_pagination[country] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E270>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[country]>>)
field_name = 'country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_pagination[company_address] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E330>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[company_address]>>)
field_name = 'company_address'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_pagination[company_city] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E3F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[company_city]>>)
field_name = 'company_city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_pagination[company_state] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E4B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[company_state]>>)
field_name = 'company_state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_pagination[company_country] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E570>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_pagination[company_country]>>)
field_name = 'company_country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_pagination(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"limit": 10, "offset": 0},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:745: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_combined[title] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19E930>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[title]>>)
field_name = 'title'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_combined[company] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19EC60>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[company]>>)
field_name = 'company'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_combined[industry] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19ED20>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[industry]>>)
field_name = 'industry'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_combined[keywords] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19EDE0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[keywords]>>)
field_name = 'keywords'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_combined[technologies] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19EEA0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[technologies]>>)
field_name = 'technologies'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_combined[city] _________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19EF60>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[city]>>)
field_name = 'city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________________ TestFieldEndpoints.test_field_combined[state] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F020>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[state]>>)
field_name = 'state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_combined[country] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F0E0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[country]>>)
field_name = 'country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_combined[company_address] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F1A0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[company_address]>>)
field_name = 'company_address'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_combined[company_city] _____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F260>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[company_city]>>)
field_name = 'company_city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_combined[company_state] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F320>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[company_state]>>)
field_name = 'company_state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_combined[company_country] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F3E0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_combined[company_country]>>)
field_name = 'company_country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_combined(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": "test", "distinct": "true", "limit": 10},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:760: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_edge_cases[title] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19F800>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[title]>>)
field_name = 'title'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_edge_cases[company] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19FBF0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[company]>>)
field_name = 'company'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_edge_cases[industry] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19FCB0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[industry]>>)
field_name = 'industry'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_____________ TestFieldEndpoints.test_field_edge_cases[keywords] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19FD70>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[keywords]>>)
field_name = 'keywords'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_edge_cases[technologies] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19FE30>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[technologies]>>)
field_name = 'technologies'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_edge_cases[city] ________________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19FEF0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[city]>>)
field_name = 'city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______________ TestFieldEndpoints.test_field_edge_cases[state] _______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A19FFB0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[state]>>)
field_name = 'state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______________ TestFieldEndpoints.test_field_edge_cases[country] ______________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C40B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[country]>>)
field_name = 'country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_edge_cases[company_address] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4170>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[company_address]>>)
field_name = 'company_address'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_edge_cases[company_city] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4230>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[company_city]>>)
field_name = 'company_city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_edge_cases[company_state] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C42F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[company_state]>>)
field_name = 'company_state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_edge_cases[company_country] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C43B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_edge_cases[company_country]>>)
field_name = 'company_country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_edge_cases(self, api_request, field_name: str):
>       api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            params={"search": ""},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_custom_request_id[title] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C47D0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[title]>>)
field_name = 'title'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/title/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/title/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_custom_request_id[company] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4BC0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[company]>>)
field_name = 'company'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_custom_request_id[industry] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4C80>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[industry]>>)
field_name = 'industry'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/industry/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/industry/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_custom_request_id[keywords] __________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4D40>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[keywords]>>)
field_name = 'keywords'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/keywords/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/keywords/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________ TestFieldEndpoints.test_field_custom_request_id[technologies] ________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4E00>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[technologies]>>)
field_name = 'technologies'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/technologies/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/technologies/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________ TestFieldEndpoints.test_field_custom_request_id[city] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A17AE70>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[city]>>)
field_name = 'city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
___________ TestFieldEndpoints.test_field_custom_request_id[state] ____________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4EC0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[state]>>)
field_name = 'state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
__________ TestFieldEndpoints.test_field_custom_request_id[country] ___________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C4FB0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[country]>>)
field_name = 'country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______ TestFieldEndpoints.test_field_custom_request_id[company_address] _______

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C5070>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[company_address]>>)
field_name = 'company_address'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_address/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_address/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
________ TestFieldEndpoints.test_field_custom_request_id[company_city] ________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C5130>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[company_city]>>)
field_name = 'company_city'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_city/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_city/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
_______ TestFieldEndpoints.test_field_custom_request_id[company_state] ________

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C51F0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[company_state]>>)
field_name = 'company_state'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_state/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_state/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
______ TestFieldEndpoints.test_field_custom_request_id[company_country] _______

self = <app.tests.integration.test_api_endpoints.TestFieldEndpoints object at 0x000001A23A1C52B0>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_field_custom_request_id[company_country]>>)
field_name = 'company_country'

    @pytest.mark.parametrize("field_name", FIELD_ENDPOINTS)
    def test_field_custom_request_id(self, api_request, field_name: str):
        header_value = f"field-{field_name}-req-123"
>       response = api_request(
            "GET",
            api_v1_path(f"/contacts/{field_name}/"),
            headers={"X-Request-Id": header_value},
            expected_status=200,
        )

app\tests\integration\test_api_endpoints.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts/company_country/'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/company_country/ returned 404, expected 200

app\tests\integration\test_api_endpoints.py:408: Failed
____________________ TestErrorScenarios.test_malformed_url ____________________

self = <app.tests.integration.test_api_endpoints.TestErrorScenarios object at 0x000001A23A1DD400>
api_request = functools.partial(<function api_request_factory.<locals>._request at 0x000001A23A978180>, request_context=<SubRequest 'api_request' for <Function test_malformed_url>>)

    def test_malformed_url(self, api_request):
>       api_request(
            "GET",
            api_v1_path("/contacts//"),
            expected_status=404,
        )

app\tests\integration\test_api_endpoints.py:995: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

method = 'GET', endpoint = '/api/v1/contacts//'

    def _request(
        method: str,
        endpoint: str,
        *,
        params: Optional[Mapping[str, Any]] = None,
        json_body: Optional[Mapping[str, Any]] = None,
        data: Optional[Mapping[str, Any]] = None,
        files: Optional[Mapping[str, Any]] = None,
        headers: Optional[Mapping[str, Any]] = None,
        expected_status: Optional[int] = 200,
        expected_statuses: Optional[Iterable[int]] = None,
        allow_timeout: bool = False,
        request_context: Optional[pytest.FixtureRequest] = None,
    ) -> requests.Response:
        url = urljoin(f"{api_base_url}/", endpoint.lstrip("/"))
        request_headers = {"X-Request-Id": f"pytest-{int(time.time() * 1000)}"}
        if headers:
            request_headers.update(headers)
    
        start_time = time.perf_counter()
    
        try:
            response = api_session.request(
                method=method,
                url=url,
                params=params,
                json=json_body if files is None else None,
                data=data,
                files=files,
                headers=request_headers,
                timeout=api_timeout,
            )
            elapsed = time.perf_counter() - start_time
        except requests.exceptions.Timeout as exc:
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=allow_timeout,
                response_time=elapsed,
                params=params,
                error=f"Timeout: {exc}",
                request_id=request_headers.get("X-Request-Id"),
            )
            if allow_timeout:
                pytest.xfail(f"Expected timeout for {method} {endpoint}")
            pytest.fail(f"{method} {url} timed out after {elapsed:.2f}s")
        except requests.exceptions.RequestException as exc:  # pragma: no cover - defensive
            elapsed = time.perf_counter() - start_time
            api_test_recorder.record(
                test_name=(
                    request_context.node.nodeid
                    if request_context is not None
                    else f"{method} {endpoint}"
                ),
                method=method,
                endpoint=endpoint,
                url=url,
                status_code=None,
                expected_status=expected_status,
                expected_statuses=expected_statuses,
                success=False,
                response_time=elapsed,
                params=params,
                error=str(exc),
                request_id=request_headers.get("X-Request-Id"),
            )
            pytest.fail(f"{method} {url} request error: {exc}")
    
        response_body = response.text or ""
        response_is_json = False
        content_preview = response_body[:500] if response_body else ""
    
        content_type = response.headers.get("content-type", "").lower()
        if "application/json" in content_type:
            try:
                json.loads(response_body)
            except ValueError:
                response_is_json = False
            else:
                response_is_json = True
    
        response_preview = content_preview
        expected_ok = True
        expectation_desc = "any status"
    
        if expected_statuses:
            expected_set = set(expected_statuses)
            expected_ok = response.status_code in expected_set
            expectation_desc = f"one of {sorted(expected_set)}"
        elif expected_status is not None:
            expected_ok = response.status_code == expected_status
            expectation_desc = str(expected_status)
    
        api_test_recorder.record(
            test_name=(
                request_context.node.nodeid
                if request_context is not None
                else f"{method} {endpoint}"
            ),
            method=method,
            endpoint=endpoint,
            url=url,
            status_code=response.status_code,
            expected_status=expected_status,
            expected_statuses=expected_statuses,
            success=expected_ok,
            response_time=elapsed,
            params=params,
            request_id=request_headers.get("X-Request-Id"),
            response_preview=response_preview,
            response_body=response_body,
            response_is_json=response_is_json,
        )
    
        if not expected_ok:
>           pytest.fail(
                f"{method} {url} returned {response.status_code}, expected {expectation_desc}"
            )
E           Failed: GET http://localhost:8000/api/v1/contacts/ returned 200, expected 404

app\tests\integration\test_api_endpoints.py:408: Failed
_________________________ test_create_contact_minimal _________________________

async_client = <httpx.AsyncClient object at 0x000001A23AD57AD0>

    @pytest.mark.asyncio
    async def test_create_contact_minimal(async_client):
        response = await async_client.post("/api/v1/contacts/", json={})
>       assert response.status_code == 201
E       assert 403 == 201
E        +  where 403 = <Response [403 Forbidden]>.status_code

app\tests\test_contacts.py:1044: AssertionError
__________________ test_create_contact_with_optional_fields ___________________

async_client = <httpx.AsyncClient object at 0x000001A23AD56FF0>

    @pytest.mark.asyncio
    async def test_create_contact_with_optional_fields(async_client):
        request_body = {
            "first_name": "Jane",
            "last_name": "Doe",
            "email": "jane.doe@example.com",
            "title": "Director of Sales",
            "departments": ["Sales", "Marketing"],
            "mobile_phone": "+1234567890",
            "email_status": "valid",
            "text_search": "Austin, TX",
            "seniority": "Director",
        }
        response = await async_client.post("/api/v1/contacts/", json=request_body)
>       assert response.status_code == 201
E       assert 403 == 201
E        +  where 403 = <Response [403 Forbidden]>.status_code

app\tests\test_contacts.py:1072: AssertionError
_________________ test_create_contact_sanitizes_blank_values __________________

async_client = <httpx.AsyncClient object at 0x000001A23ABC78C0>

    @pytest.mark.asyncio
    async def test_create_contact_sanitizes_blank_values(async_client):
        request_body = {
            "first_name": "  ",
            "last_name": "",
            "email": "  user@example.com ",
            "title": None,
            "departments": ["Sales", "", "  "],
            "mobile_phone": " '+1 555-0100 ",
            "email_status": "_",
            "text_search": "  Austin ",
            "company_id": " ",
            "seniority": "",
        }
        response = await async_client.post("/api/v1/contacts/", json=request_body)
>       assert response.status_code == 201
E       assert 403 == 201
E        +  where 403 = <Response [403 Forbidden]>.status_code

app\tests\test_contacts.py:1105: AssertionError
____________ test_list_industries_separated_returns_sorted_unique _____________

async_client = <httpx.AsyncClient object at 0x000001A23AD57290>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23AD56780>

    @pytest.mark.asyncio
    async def test_list_industries_separated_returns_sorted_unique(async_client, monkeypatch):
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                assert array_mode is True
                assert params.distinct is True
                return [" Cloud", "SaaS", "Cloud", "", None]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get("/api/v1/contacts/industry/", params={"separated": "true"})
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1213: AssertionError
________________ test_list_industries_collapsed_filters_empty _________________

async_client = <httpx.AsyncClient object at 0x000001A23AD57560>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23ADBB4D0>

    @pytest.mark.asyncio
    async def test_list_industries_collapsed_filters_empty(async_client, monkeypatch):
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                assert array_mode is False
                return ["Software,Technology", "", None]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get("/api/v1/contacts/industry/")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1234: AssertionError
___________ test_list_technologies_separated_returns_sorted_unique ____________

async_client = <httpx.AsyncClient object at 0x000001A23ADFDA60>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23ADFD9D0>

    @pytest.mark.asyncio
    async def test_list_technologies_separated_returns_sorted_unique(async_client, monkeypatch):
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                assert array_mode is True
                assert params.distinct is True
                return [" Python", "AWS", "Python", "", None]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get("/api/v1/contacts/technologies/", params={"separated": "true"})
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1256: AssertionError
_________ test_list_technologies_separated_returns_unique_up_to_limit _________

async_client = <httpx.AsyncClient object at 0x000001A23ADFF650>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001A23ADFEF30>

    @pytest.mark.asyncio
    async def test_list_technologies_separated_returns_unique_up_to_limit(async_client, db_session):
        company_alpha = await create_company(
            db_session,
            technologies=["Outlook", "Remote"],
            name="Alpha Tech",
        )
        company_beta = await create_company(
            db_session,
            technologies=["Outlook", "Slack"],
            name="Beta Tech",
        )
        await create_contact(
            db_session,
            company=company_alpha,
            first_name="Alpha",
            email="alpha@example.com",
        )
        await create_contact(
            db_session,
            company=company_beta,
            first_name="Beta",
            email="beta@example.com",
        )
    
        response = await async_client.get(
            "/api/v1/contacts/technologies/",
            params={"separated": "true", "limit": "2", "ordering": "value"},
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1289: AssertionError
_______________ test_list_technologies_collapsed_filters_empty ________________

async_client = <httpx.AsyncClient object at 0x000001A23ADD8830>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23ADD9A00>

    @pytest.mark.asyncio
    async def test_list_technologies_collapsed_filters_empty(async_client, monkeypatch):
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                assert array_mode is False
                return ["Python,AWS", "", None]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get("/api/v1/contacts/technologies/")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1311: AssertionError
__________________________ test_list_titles_distinct __________________________

async_client = <httpx.AsyncClient object at 0x000001A23ADFC680>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001A23ADFC500>

    @pytest.mark.asyncio
    async def test_list_titles_distinct(async_client, db_session):
        await create_contact(
            db_session,
            first_name="Title One",
            email="title1@example.com",
            title="Director",
        )
        await create_contact(
            db_session,
            first_name="Title Two",
            email="title2@example.com",
            title="Director",
        )
        placeholder_titles = ["_", "....", "//////", "?"]
        for idx, title in enumerate(placeholder_titles):
            await create_contact(
                db_session,
                first_name=f"Placeholder {idx}",
                email=f"placeholder{idx}@example.com",
                title=title,
            )
    
        response = await async_client.get("/api/v1/contacts/title/", params={"distinct": "true"})
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1407: AssertionError
_______ test_list_companies_distinct_search_emits_no_cartesian_warnings _______

async_client = <httpx.AsyncClient object at 0x000001A23ADBA150>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001A23ADBB980>

    @pytest.mark.asyncio
    async def test_list_companies_distinct_search_emits_no_cartesian_warnings(async_client, db_session):
        company = await create_company(db_session, name="DCS Systems")
        await create_contact(
            db_session,
            company=company,
            first_name="NoWarning",
            email="nowarning@example.com",
            title="Director",
        )
    
        with warnings.catch_warnings(record=True) as captured:
            warnings.simplefilter("always", SAWarning)
            response = await async_client.get(
                "/api/v1/contacts/company/",
                params={"distinct": "true", "search": "DCS"},
            )
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1432: AssertionError
_____________ test_list_keywords_separated_handles_mixed_formats ______________

async_client = <httpx.AsyncClient object at 0x000001A23AD573B0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23AD56BA0>

    @pytest.mark.asyncio
    async def test_list_keywords_separated_handles_mixed_formats(async_client, monkeypatch):
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                assert array_mode is True
                assert params.distinct is True
                return [
                    " SaaS ",
                    ["AI", "ML"],
                    '["Cloud","AI"]',
                    '{"DevOps","AI"}',
                    None,
                    "",
                ]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get("/api/v1/contacts/keywords/", params={"separated": "true"})
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1468: AssertionError
________________ test_list_company_address_returns_text_search ________________

async_client = <httpx.AsyncClient object at 0x000001A23ADBACF0>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001A23ABC3BF0>

    @pytest.mark.asyncio
    async def test_list_company_address_returns_text_search(async_client, db_session):
        company = await create_company(
            db_session,
            name="Text Search Co",
            text_search="123 Example St, Austin, TX",
        )
        await create_contact(
            db_session,
            company=company,
            first_name="Tessa",
            email="tessa@example.com",
        )
        response = await async_client.get("/api/v1/contacts/company_address/")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1486: AssertionError
________________ test_list_contact_address_returns_text_search ________________

async_client = <httpx.AsyncClient object at 0x000001A23ADD93D0>
db_session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x000001A23ADDBB60>

    @pytest.mark.asyncio
    async def test_list_contact_address_returns_text_search(async_client, db_session):
        await create_contact(
            db_session,
            first_name="Carlos",
            email="carlos@example.com",
            text_search="456 Sample Ave, Denver, CO",
        )
        response = await async_client.get("/api/v1/contacts/contact_address/")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1499: AssertionError
________________ test_attribute_endpoints_accept_params[title] ________________

async_client = <httpx.AsyncClient object at 0x000001A23ADD9070>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23ADD84D0>
endpoint = 'title'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
_______________ test_attribute_endpoints_accept_params[company] _______________

async_client = <httpx.AsyncClient object at 0x000001A23AE41070>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23AE42930>
endpoint = 'company'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
___________ test_attribute_endpoints_accept_params[company_address] ___________

async_client = <httpx.AsyncClient object at 0x000001A23AE42D20>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23AE41A00>
endpoint = 'company_address'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
___________ test_attribute_endpoints_accept_params[contact_address] ___________

async_client = <httpx.AsyncClient object at 0x000001A23C09CE30>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23C09C8F0>
endpoint = 'contact_address'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
______________ test_attribute_endpoints_accept_params[industry] _______________

async_client = <httpx.AsyncClient object at 0x000001A23C09DCA0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23C09E4B0>
endpoint = 'industry'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
______________ test_attribute_endpoints_accept_params[keywords] _______________

async_client = <httpx.AsyncClient object at 0x000001A23C09F3E0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23C09C680>
endpoint = 'keywords'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
____________ test_attribute_endpoints_accept_params[technologies] _____________

async_client = <httpx.AsyncClient object at 0x000001A23C09E750>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x000001A23C09FE00>
endpoint = 'technologies'

    @pytest.mark.asyncio
    @pytest.mark.parametrize(
        "endpoint",
        [
            "title",
            "company",
            "company_address",
            "contact_address",
            "industry",
            "keywords",
            "technologies",
        ],
    )
    async def test_attribute_endpoints_accept_params(async_client, monkeypatch, endpoint):
        captured = {}
    
        class DummyService:
            async def list_attribute_values(
                self,
                session,
                filters,
                params,
                *,
                column_factory,
                array_mode: bool = False,
            ):
                captured["filters"] = filters
                captured["params"] = params
                captured["array_mode"] = array_mode
                captured["column_factory"] = column_factory
                return ["Value One", "Value Two"]
    
        monkeypatch.setattr(contacts_endpoints, "service", DummyService())
        response = await async_client.get(
            f"/api/v1/contacts/{endpoint}/",
            params={
                "limit": "5",
                "offset": "10",
                "distinct": "true",
                "search": "Query",
                "ordering": "name",
                "contact_location": "Austin",
            },
        )
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_contacts.py:1547: AssertionError
__________________________ test_import_info_endpoint __________________________

async_client = <httpx.AsyncClient object at 0x000001A23AE40C50>

    @pytest.mark.asyncio
    async def test_import_info_endpoint(async_client):
        response = await async_client.get("/api/v1/contacts/import/")
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

app\tests\test_imports.py:14: AssertionError
=========================== short test summary info ===========================
SKIPPED [1] app\tests\integration\test_api_endpoints.py:484: Versioned health endpoint not available
SKIPPED [1] app\tests\integration\test_api_endpoints.py:813: Admin credentials required for CSV upload tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:831: Admin credentials required for CSV upload tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:848: Admin credentials required for CSV upload tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:861: Admin credentials required for CSV upload tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:876: Admin credentials required for CSV upload tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:894: Admin credentials required to create import jobs
SKIPPED [1] app\tests\integration\test_api_endpoints.py:903: Admin credentials required for import detail tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:913: Admin credentials required to create import jobs
SKIPPED [1] app\tests\integration\test_api_endpoints.py:923: Admin credentials required for import error download tests
SKIPPED [1] app\tests\integration\test_api_endpoints.py:945: Admin credentials required for authenticated admin tests
XFAIL app/tests/integration/test_api_endpoints.py::TestContactsList::test_special_character_search - Expected timeout for GET /api/v1/contacts/
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_individual_filters[created_at_after-2024-01-01T00:00:00Z]
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_individual_filters[created_at_before-2025-01-01T00:00:00Z]
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_individual_filters[updated_at_after-2024-01-01T00:00:00Z]
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_individual_filters[updated_at_before-2025-01-01T00:00:00Z]
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_filter_combinations[params6]
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_filter_combinations[params7]
FAILED app/tests/integration/test_api_endpoints.py::TestContactsList::test_multiple_ordering
FAILED app/tests/integration/test_api_endpoints.py::TestContactsCount::test_count_with_date_range
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_basic[company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[fintech-company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_search[tech-company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_distinct[company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_pagination[company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_combined[company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_edge_cases[company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[title]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[company]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[industry]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[keywords]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[technologies]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[country]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[company_address]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[company_city]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[company_state]
FAILED app/tests/integration/test_api_endpoints.py::TestFieldEndpoints::test_field_custom_request_id[company_country]
FAILED app/tests/integration/test_api_endpoints.py::TestErrorScenarios::test_malformed_url
FAILED app/tests/test_contacts.py::test_create_contact_minimal - assert 403 =...
FAILED app/tests/test_contacts.py::test_create_contact_with_optional_fields
FAILED app/tests/test_contacts.py::test_create_contact_sanitizes_blank_values
FAILED app/tests/test_contacts.py::test_list_industries_separated_returns_sorted_unique
FAILED app/tests/test_contacts.py::test_list_industries_collapsed_filters_empty
FAILED app/tests/test_contacts.py::test_list_technologies_separated_returns_sorted_unique
FAILED app/tests/test_contacts.py::test_list_technologies_separated_returns_unique_up_to_limit
FAILED app/tests/test_contacts.py::test_list_technologies_collapsed_filters_empty
FAILED app/tests/test_contacts.py::test_list_titles_distinct - assert 404 == 200
FAILED app/tests/test_contacts.py::test_list_companies_distinct_search_emits_no_cartesian_warnings
FAILED app/tests/test_contacts.py::test_list_keywords_separated_handles_mixed_formats
FAILED app/tests/test_contacts.py::test_list_company_address_returns_text_search
FAILED app/tests/test_contacts.py::test_list_contact_address_returns_text_search
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[title]
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[company]
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[company_address]
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[contact_address]
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[industry]
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[keywords]
FAILED app/tests/test_contacts.py::test_attribute_endpoints_accept_params[technologies]
FAILED app/tests/test_imports.py::test_import_info_endpoint - assert 404 == 200
126 failed, 174 passed, 11 skipped, 1 xfailed in 611.59s (0:10:11)
